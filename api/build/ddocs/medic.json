{
  "docs": [
    {
      "_id": "_design/medic",
      "build_info": {
        "application": "medic",
        "author": "npm on kossi",
        "base_version": "4.10.0",
        "build": "4.10.0-dev.1723635703462",
        "schema_version": 2,
        "namespace": "medic",
        "time": "2024-08-14T11:41:43.565Z",
        "version": "4.10.0-local-development"
      },
      "rewrites": [
        {
          "from": "/manifest.appcache",
          "to": "manifest.appcache"
        }
      ],
      "validate_doc_update": "/*\n  SERVER DOCUMENT VALIDATION\n\n  This is for validating authority. It is against the medic ddoc because it can\n  only usefully be run against couchdb.\n\n  For validations around document structure (and for a validate_doc_update script\n  that runs on PouchDB) check ddocs/medic-client/validate_doc_update.js.\n*/\nfunction(newDoc, oldDoc, userCtx, secObj) {\n\n  var ADMIN_ONLY_TYPES = [ 'form', 'translations', 'token_login' ];\n  var ADMIN_ONLY_IDS = [\n    'resources',\n    'service-worker-meta',\n    'zscore-charts',\n    'settings',\n    'branding',\n    'partners',\n    'privacy-policies',\n    'extension-libs',\n  ];\n\n  var _err = function(msg) {\n    throw({ forbidden: msg });\n  };\n\n  var hasRole = function(roles, role) {\n    if (roles) {\n      for (var i = 0; i < roles.length; i++) {\n        if (roles[i] === role) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  var isDbAdmin = function(userCtx, secObj) {\n    if (hasRole(userCtx.roles, '_admin')) {\n      return true;\n    }\n\n    if (secObj.admins && secObj.admins.names && secObj.admins.names.indexOf(userCtx.name) !== -1) {\n      return true;\n    }\n\n    if (secObj.admins && secObj.admins.roles) {\n      for (var i = 0; i < userCtx.roles.length; i++) {\n        if (hasRole(secObj.admins.roles, userCtx.roles[i])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  var isAdminOnlyDoc = function(doc) {\n    return (doc._id && doc._id.indexOf('_design/') === 0) ||\n           (doc._id && ADMIN_ONLY_IDS.indexOf(doc._id) !== -1) ||\n           (doc.type && ADMIN_ONLY_TYPES.indexOf(doc.type) !== -1);\n  };\n\n  var checkAuthority = function(newDoc, oldDoc, userCtx, secObj) {\n\n    // ensure logged in\n    if (!userCtx.name) {\n      _err('You must be logged in to edit documents');\n    }\n\n    // admins can do anything\n    if (isDbAdmin(userCtx, secObj)) {\n      return;\n    }\n\n    if (isAdminOnlyDoc(newDoc) || (oldDoc && isAdminOnlyDoc(oldDoc))) {\n      _err('You are not authorized to edit admin only docs');\n    }\n\n    if (userCtx.facility_id === newDoc._id ||\n      (Array.isArray(userCtx.facility_id) && userCtx.facility_id.includes(newDoc._id ))\n    ) {\n      _err('You are not authorized to edit your own place');\n    }\n  };\n\n  if (newDoc.purged) {\n    // Remove this once we move purging to the server side, for now it is to\n    // prevent *client-side* purging from leaking into the server side\n    return _err('Purged documents should not be written to CouchDB!');\n  }\n\n  checkAuthority(newDoc, oldDoc, userCtx, secObj);\n  log('medic validate_doc_update passed for User \"' + userCtx.name + '\" changing document \"' +  newDoc._id + '\"');\n}",
      "version": "4.10.0-dev.1723635703462",
      "views": {
        "contacts_by_depth": {
          "map": "function(doc) {\n  if (['contact', 'person', 'clinic', 'health_center', 'district_hospital'].indexOf(doc.type) !== -1) {\n    var value = doc.patient_id || doc.place_id;\n    var parent = doc;\n    var depth = 0;\n    while (parent) {\n      if (parent._id) {\n        emit([parent._id], value);\n        emit([parent._id, depth], value);\n      }\n      depth++;\n      parent = parent.parent;\n    }\n  }\n}"
        },
        "docs_by_replication_key": {
          "map": "function (doc) {\n  if (doc._id === 'resources' ||\n      doc._id === 'branding' ||\n      doc._id === 'partners' ||\n      doc._id === 'service-worker-meta' ||\n      doc._id === 'zscore-charts' ||\n      doc._id === 'settings' ||\n      doc._id === 'privacy-policies' ||\n      doc.type === 'form' ||\n      doc.type === 'translations') {\n    return emit('_all', {});\n  }\n  var getSubject = function() {\n    if (doc.form) {\n      // report\n      if (doc.contact && doc.errors && doc.errors.length) {\n        for (var i = 0; i < doc.errors.length; i++) {\n          // invalid or no patient found, fall back to using contact. #3437\n          if (doc.errors[i].code === 'registration_not_found' ||\n              doc.errors[i].code === 'invalid_patient_id') {\n            return doc.contact._id;\n          }\n        }\n      }\n      return (doc.patient_id || (doc.fields && doc.fields.patient_id)) ||\n             (doc.place_id || (doc.fields && doc.fields.place_id)) ||\n             (doc.fields && doc.fields.patient_uuid) ||\n             (doc.contact && doc.contact._id);\n    }\n    if (doc.sms_message) {\n      // incoming message\n      return doc.contact && doc.contact._id;\n    }\n    if (doc.kujua_message) {\n      // outgoing message\n      return doc.tasks &&\n             doc.tasks[0] &&\n             doc.tasks[0].messages &&\n             doc.tasks[0].messages[0] &&\n             doc.tasks[0].messages[0].contact &&\n             doc.tasks[0].messages[0].contact._id;\n    }\n  };\n  var value = { type: doc.type };\n  switch (doc.type) {\n    case 'data_record':\n      value.subject = getSubject() || '_unassigned';\n      if (doc.form && doc.contact) {\n        value.submitter = doc.contact._id;\n      }\n      if (doc.fields && doc.fields.private) {\n        value.private = true;\n      }\n      emit(value.subject, value);\n      if (doc.fields &&\n          doc.fields.needs_signoff &&\n          doc.contact\n      ) {\n        value.needs_signoff = true;\n        var contact = doc.contact;\n        while (contact) {\n          if (contact._id && contact._id !== value.subject) {\n            emit(contact._id, value);\n          }\n          contact = contact.parent;\n        }\n      }\n      return;\n    case 'task':\n      return emit(doc.user, value);\n    case 'target':\n      return emit(doc.owner, value);\n    case 'contact':\n    case 'clinic':\n    case 'district_hospital':\n    case 'health_center':\n    case 'person':\n      return emit(doc._id, value);\n  }\n}"
        },
        "doc_summaries_by_id": {
          "map": "// WARNING: This is a copy of the GetSummaries service\n// with some minor modifications and needs to be kept in sync until\n// this workaround is no longer needed.\n// https://github.com/medic/medic/issues/4666\n\nfunction(doc) {\n  var getLineage = function(contact) {\n    var parts = [];\n    while (contact) {\n      if (contact._id) {\n        parts.push(contact._id);\n      }\n      contact = contact.parent;\n    }\n    return parts;\n  };\n\n  var isMissingSubjectError = function(error) {\n    if (error.code !== 'sys.missing_fields' || !error.fields) {\n      return false;\n    }\n\n    if (error.fields.indexOf('patient_id') !== -1 ||\n      error.fields.indexOf('patient_uuid') !== -1 ||\n      error.fields.indexOf('patient_name') !== -1 ||\n      error.fields.indexOf('place_id') !== -1) {\n      return true;\n    }\n\n    return false;\n  };\n\n  var getSubject = function(doc) {\n    var subject = {};\n    var reference = doc.patient_id ||\n                    (doc.fields && doc.fields.patient_id) ||\n                    (doc.fields && doc.fields.patient_uuid) ||\n                    doc.place_id ||\n                    (doc.fields && doc.fields.place_id);\n\n    var patientName = doc.fields && doc.fields.patient_name;\n    if (patientName) {\n      subject.name = patientName;\n    }\n\n    if (reference) {\n      subject.value = reference;\n      subject.type = 'reference';\n    } else if (patientName) {\n      subject.value = patientName;\n      subject.type = 'name';\n    } else if (doc.errors) {\n      doc.errors.forEach(function(error) {\n        if (isMissingSubjectError(error)) {\n          subject.type = 'unknown';\n        }\n      });\n    }\n\n    return subject;\n  };\n\n  if (doc.type === 'data_record' && doc.form) { // report\n    emit(doc._id, {\n      _rev: doc._rev,\n      from: doc.from || doc.sent_by,\n      phone: doc.contact && doc.contact.phone,\n      form: doc.form,\n      read: doc.read,\n      valid: !doc.errors || !doc.errors.length,\n      verified: doc.verified,\n      reported_date: doc.reported_date,\n      contact: doc.contact && doc.contact._id,\n      lineage: getLineage(doc.contact && doc.contact.parent),\n      subject: getSubject(doc),\n      case_id: doc.case_id || (doc.fields && doc.fields.case_id)\n    });\n  } else if (doc.type === 'contact' ||\n      doc.type === 'clinic' ||\n      doc.type === 'district_hospital' ||\n      doc.type === 'health_center' ||\n      doc.type === 'person') { // contact\n    emit(doc._id, {\n      _rev: doc._rev,\n      name: doc.name || doc.phone,\n      phone: doc.phone,\n      type: doc.type,\n      contact_type: doc.contact_type,\n      contact: doc.contact && doc.contact._id,\n      lineage: getLineage(doc.parent),\n      date_of_death: doc.date_of_death,\n      muted: doc.muted\n    });\n  }\n}"
        },
        "messages_by_state": {
          "map": "function (doc) {\n  var _emit = function(tasks) {\n    tasks.forEach(function(task) {\n      var due = task.due || task.timestamp || // for scheduled_message\n                doc.reported_date; // for immediate reply to form submission\n      if (typeof due === 'string') {\n        due = Date.parse(due).valueOf();\n      }\n      if (task.messages) {\n        task.messages.forEach(function(msg) {\n          if (msg.uuid && msg.to && msg.message) {\n            var value = {\n              content: msg.message,\n              to: msg.to,\n              id: msg.uuid,\n            };\n            emit([ task.state, due ], value);\n            if (task.state === 'pending' || task.state === 'forwarded-to-gateway') {\n              // emit a single state so we can sort by due date in the view\n              emit([ 'pending-or-forwarded', due ], value);\n            }\n          }\n        });\n      } else {\n        emit([ task.state, due ], {});\n      }\n    });\n  };\n  _emit(doc.tasks || []);\n  _emit(doc.scheduled_tasks || []);\n}"
        },
        "docs_by_shortcode": {
          "map": "function(doc) {\n  if (doc.place_id) {\n    emit(doc.place_id);\n  }\n  if (doc.patient_id) {\n    emit(doc.patient_id);\n  }\n  if (doc.case_id) {\n    emit(doc.case_id);\n  }\n}"
        },
        "reports_by_form_and_parent": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' &&\n      doc.form &&\n      doc.contact &&\n      doc.contact.parent) {\n    var value = typeof doc.reported_date === 'number' ? doc.reported_date : 0;\n    emit([doc.form, doc.contact.parent._id], value);\n  }\n}",
          "reduce": "_stats"
        },
        "reports_by_form_year_month_parent_reported_date": {
          "map": "function (doc) {\n  if (doc.type === 'data_record' &&\n      doc.contact &&\n      doc.contact.parent &&\n      doc.fields &&\n      doc.fields.year &&\n      (doc.fields.month || doc.fields.month_num) &&\n      doc.form &&\n      doc.reported_date) {\n    emit([\n      doc.form,\n      doc.fields.year,\n      doc.fields.month || doc.fields.month_num,\n      doc.contact.parent._id,\n      doc.reported_date\n    ]);\n  }\n}"
        },
        "tasks_in_terminal_state": {
          "map": "function(doc) {\n  if (doc.type === 'task') {\n    var isTerminalState = ['Cancelled', 'Completed', 'Failed'].indexOf(doc.state) >= 0;\n    if (isTerminalState && doc.emission) {\n      emit(doc.emission.endDate);\n    }\n  }\n}"
        },
        "reports_by_form_year_week_parent_reported_date": {
          "map": "function (doc) {\n  if (doc.type === 'data_record' &&\n      doc.contact &&\n      doc.contact.parent &&\n      doc.fields &&\n      doc.fields.year &&\n      (doc.fields.week || doc.fields.week_number) &&\n      doc.form &&\n      doc.reported_date) {\n    emit([\n      doc.form,\n      doc.fields.year,\n      doc.fields.week || doc.fields.week_number,\n      doc.contact.parent._id,\n      doc.reported_date\n    ]);\n  }\n}"
        }
      }
    },
    {
      "build_info": {
        "application": "medic",
        "author": "npm on kossi",
        "build": "4.10.0-dev.1723635703462",
        "base_version": "4.10.0",
        "namespace": "medic",
        "schema_version": 2,
        "time": "2024-08-14T11:41:43.565Z",
        "version": "4.10.0-local-development"
      },
      "_id": "_design/medic-admin",
      "version": "4.10.0-dev.1723635703462",
      "views": {
        "message_queue": {
          "map": "function (doc) {\n  var mutedStatuses = ['muted', 'cleared', 'denied', 'duplicate'];\n  var scheduledStatus = 'scheduled';\n  var successStatuses = ['delivered', 'sent'];\n  var failureStatuses = ['failed'];\n\n  var _emitValue = function(keys, value) {\n    keys.forEach(function(key) {\n      if (key && key[0]) {\n        emit(key, value);\n      }\n    })\n  }\n\n  var _emit = function(tasks) {\n    tasks.forEach(function(task) {\n      var due = new Date(task.due || task.timestamp || doc.reported_date).getTime();\n      var dueMutedKey = ['due', due];\n      var deliveredFailureKey = [undefined, due];\n      var keys = [dueMutedKey, deliveredFailureKey];\n\n      if (task.state === scheduledStatus) {\n        dueMutedKey[0] = 'scheduled';\n      } else if (mutedStatuses.indexOf(task.state) > -1) {\n        dueMutedKey[0] = 'muted';\n      }\n      if (successStatuses.indexOf(task.state) > -1) {\n        deliveredFailureKey[0] = 'delivered';\n      }\n      if (failureStatuses.indexOf(task.state) > -1) {\n        deliveredFailureKey[0] = 'failed';\n      }\n\n      var taskData = {\n        state_history: task.state_history && task.state_history[task.state_history.length - 1],\n        state: task.state,\n        group: task.group,\n        translation_key: task.translation_key,\n        type: task.type\n      };\n\n      if(task.messages) {\n        task.messages.forEach(function(msg) {\n          if (msg.uuid && msg.to && msg.message) {\n            var value = {\n              sms: {\n                message: msg.message,\n                to: msg.to\n              },\n              task: taskData,\n              due: due\n            };\n\n            _emitValue(keys, value);\n          }\n        });\n      } else {\n        // generate the messages before displaying them in the admin console\n        var value = {\n          scheduled_sms: {\n            translation_key: task.message_key,\n            recipient: task.recipient,\n            content: task.message\n          },\n          task: taskData,\n          due: due\n        };\n\n        _emitValue(keys, value);\n      }\n\n    });\n  };\n  _emit(doc.tasks || []);\n  _emit(doc.scheduled_tasks || []);\n}",
          "reduce": "_count"
        },
        "contacts_by_dhis_orgunit": {
          "map": "function(doc) {\n  if (\n    doc.dhis &&\n    ['contact', 'person', 'clinic', 'health_center', 'district_hospital'].indexOf(doc.type) !== -1\n  ) {\n    if (Array.isArray(doc.dhis)) {\n      for (var i = 0; i < doc.dhis.length; ++i) {\n        emit(doc.dhis[i].orgUnit);\n      }\n    } else {\n      emit(doc.dhis.orgUnit);\n    }\n  }\n}"
        }
      }
    },
    {
      "build_info": {
        "author": "npm on kossi",
        "application": "medic",
        "build": "4.10.0-dev.1723635703462",
        "base_version": "4.10.0",
        "schema_version": 2,
        "namespace": "medic",
        "time": "2024-08-14T11:41:43.565Z",
        "version": "4.10.0-local-development"
      },
      "_id": "_design/medic-client",
      "validate_doc_update": "function(newDoc, oldDoc, userCtx, secObj) {\n  /*\n    LOCAL DOCUMENT VALIDATION\n\n    This is for validating document structure, irrespective of authority, so it\n    can be run both on couchdb and pouchdb (where you are technically admin).\n\n    For validations around authority check lib/validate_doc_update.js, which is\n    only run on the server.\n  */\n\n  var _err = function(msg) {\n    throw({ forbidden: msg });\n  };\n\n  var hasRole = function(roles, role) {\n    if (roles) {\n      for (var i = 0; i < roles.length; i++) {\n        if (roles[i] === role) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  var isDbAdmin = function(userCtx, secObj) {\n    if (hasRole(userCtx.roles, '_admin')) {\n      return true;\n    }\n\n    if (secObj.admins && secObj.admins.names && secObj.admins.names.indexOf(userCtx.name) !== -1) {\n      return true;\n    }\n\n    if (secObj.admins && secObj.admins.roles) {\n      for (var i = 0; i < userCtx.roles.length; i++) {\n        if (hasRole(secObj.admins.roles, userCtx.roles[i])) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Ensure that type='form' documents are created with correctly formatted _id\n   * property.\n   */\n  var validateForm = function() {\n    var id_parts = newDoc._id.split(':');\n    var prefix = id_parts[0];\n    var form_id = id_parts.slice(1).join(':');\n    if (prefix !== 'form') {\n      _err('_id property must be prefixed with \"form:\". e.g. \"form:registration\"');\n    }\n    if (!form_id) {\n      _err('_id property must define a value after \"form:\". e.g. \"form:registration\"');\n    }\n    if (newDoc._id !== newDoc._id.toLowerCase()) {\n      _err('_id property must be lower case. e.g. \"form:registration\"');\n    }\n  };\n\n  var validateUserSettings = function() {\n    var id_parts = newDoc._id.split(':');\n    var prefix = id_parts[0];\n    var username = id_parts.slice(1).join(':');\n    var idExample = ' e.g. \"org.couchdb.user:sally\"';\n    if (prefix !== 'org.couchdb.user') {\n      _err('_id must be prefixed with \"org.couchdb.user:\".' + idExample);\n    }\n    if (!username) {\n      _err('_id must define a value after \"org.couchdb.user:\".' + idExample);\n    }\n    if (newDoc._id !== newDoc._id.toLowerCase()) {\n      _err('_id must be lower case.' + idExample);\n    }\n    if (typeof newDoc.name === 'undefined' || newDoc.name !== username) {\n      _err('name property must be equivalent to username.' + idExample);\n    }\n    if (newDoc.name.toLowerCase() !== username.toLowerCase()) {\n      _err('name must be equivalent to username');\n    }\n    if (typeof newDoc.known !== 'undefined' && typeof newDoc.known !== 'boolean') {\n      _err('known is not a boolean.');\n    }\n    if (typeof newDoc.roles !== 'object') {\n      _err('roles is a required array');\n    }\n  };\n\n  var authorizeUserSettings = function() {\n    if (!oldDoc) {\n      _err('You are not authorized to create user-settings');\n    }\n    if (typeof oldDoc.roles !== 'object') {\n      _err('You are not authorized to edit roles');\n    }\n    if (newDoc.roles.length !== oldDoc.roles.length) {\n      _err('You are not authorized to edit roles');\n    }\n    for (var i = 0; i < oldDoc.roles.length; i++) {\n      if (oldDoc.roles[i] !== newDoc.roles[i]) {\n        _err('You are not authorized to edit roles');\n      }\n    }\n  }\n\n  // admins can do anything\n  if (isDbAdmin(userCtx, secObj)) {\n    return;\n  }\n  if (userCtx.facility_id === newDoc._id ||\n    (Array.isArray(userCtx.facility_id) && userCtx.facility_id.includes(newDoc._id ))\n  ) {\n    _err('You are not authorized to edit your own place');\n  }\n  if (newDoc.type === 'form') {\n    validateForm();\n  }\n  if (newDoc.type === 'user-settings') {\n    validateUserSettings();\n    authorizeUserSettings();\n  }\n\n  log(\n    'medic-client validate_doc_update passed for User \"' + userCtx.name +\n    '\" changing document \"' +  newDoc._id + '\"'\n  );\n}",
      "views": {
        "contacts_by_date": {
          "map": "function(doc) {\n  var tombstone = false;\n  if (doc.type === 'tombstone' && doc.tombstone) {\n    tombstone = true;\n    doc = doc.tombstone;\n  }\n  var types = [ \n    'country', \n    'region', \n    'prefecture', \n    'commune', \n    'hospital', \n    'district_hospital', \n    'health_center', \n    'clinic', \n    'person' \n  ];\n  var idx;\n  var type;\n  if (doc.type === 'contact') {\n    type = doc.contact_type;\n    idx = types.indexOf(type);\n    if (idx === -1) {\n      idx = type;\n    }\n  } else {\n    type = doc.type;\n    idx = types.indexOf(type);\n  }\n  if (tombstone) {\n    type = 'tombstone-' + type;\n  }\n  if (idx !== -1) {\n    emit([doc.reported_date], doc.reported_date);\n    /*var dead = !!doc.date_of_death;*/\n    /*var muted = !!doc.muted;*/\n    /*var order = dead + ' ' + muted + ' ' + idx + ' ' + (doc.name && doc.name.toLowerCase());*/\n    /*emit([doc.reported_date],type);*/\n    /*emit([doc.reported_date],order);*/\n    /*emit([type],order);*/\n  }\n}"
        },
        "contacts_by_freetext": {
          "map": "function(doc) {\n  var skip = [ '_id', '_rev', 'type', 'refid', 'geolocation' ];\n\n  var usedKeys = [];\n  var emitMaybe = function(key, value) {\n    if (usedKeys.indexOf(key) === -1 && // Not already used\n        key.length > 2 // Not too short\n    ) {\n      usedKeys.push(key);\n      emit([key], value);\n    }\n  };\n\n  var emitField = function(key, value, order) {\n    if (!key || !value) {\n      return;\n    }\n    key = key.toLowerCase();\n    if (skip.indexOf(key) !== -1 || /_date$/.test(key)) {\n      return;\n    }\n    if (typeof value === 'string') {\n      value = value.toLowerCase();\n      value.split(/\\s+/).forEach(function(word) {\n        emitMaybe(word, order);\n      });\n    }\n    if (typeof value === 'number' || typeof value === 'string') {\n      emitMaybe(key + ':' + value, order);\n    }\n  };\n\n  var types = [ 'district_hospital', 'health_center', 'clinic', 'person' ];\n  var idx;\n  if (doc.type === 'contact') {\n    idx = types.indexOf(doc.contact_type);\n    if (idx === -1) {\n      idx = doc.contact_type;\n    }\n  } else {\n    idx = types.indexOf(doc.type);\n  }\n\n  if (idx !== -1) {\n    var dead = !!doc.date_of_death;\n    var muted = !!doc.muted;\n    var order = dead + ' ' + muted + ' ' + idx + ' ' + (doc.name && doc.name.toLowerCase());\n    Object.keys(doc).forEach(function(key) {\n      emitField(key, doc[key], order);\n    });\n  }\n}"
        },
        "contacts_by_last_visited": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' &&\n      doc.form &&\n      doc.fields &&\n      doc.fields.visited_contact_uuid) {\n\n    var date = doc.fields.visited_date ? Date.parse(doc.fields.visited_date) : doc.reported_date;\n    if (typeof date !== 'number' || isNaN(date)) {\n      date = 0;\n    }\n    // Is a visit report about a family\n    emit(doc.fields.visited_contact_uuid, date);\n  } else if (doc.type === 'contact' ||\n             doc.type === 'clinic' ||\n             doc.type === 'health_center' ||\n             doc.type === 'district_hospital' ||\n             doc.type === 'person') {\n    // Is a contact type\n    emit(doc._id, 0);\n  }\n}",
          "reduce": "_stats"
        },
        "contacts_by_parent": {
          "map": "function(doc) {\n  if (doc.type === 'contact' ||\n      doc.type === 'clinic' ||\n      doc.type === 'health_center' ||\n      doc.type === 'district_hospital' ||\n      doc.type === 'person') {\n    var parentId = doc.parent && doc.parent._id;\n    var type = doc.type === 'contact' ? doc.contact_type : doc.type;\n    if (parentId) {\n      emit([parentId, type]);\n    }\n  }\n}"
        },
        "contacts_by_place": {
          "map": "function(doc) {\n  var types = [ 'district_hospital', 'health_center', 'clinic', 'person' ];\n  var idx;\n  if (doc.type === 'contact') {\n    idx = types.indexOf(doc.contact_type);\n    if (idx === -1) {\n      idx = doc.contact_type;\n    }\n  } else {\n    idx = types.indexOf(doc.type);\n  }\n  if (idx !== -1) {\n    var place = doc.parent;\n    var order = idx + ' ' + (doc.name && doc.name.toLowerCase());\n    while (place) {\n      if (place._id) {\n        emit([ place._id ], order);\n      }\n      place = place.parent;\n    }\n  }\n}"
        },
        "contacts_by_phone": {
          "map": "function(doc) {\n  if (doc.phone) {\n    var types = [ 'contact', 'district_hospital', 'health_center', 'clinic', 'person' ];\n    if (types.indexOf(doc.type) !== -1) {\n      emit(doc.phone);\n    }\n  }\n}"
        },
        "contacts_by_reference": {
          "map": "function(doc) {\n  if (doc.type === 'contact' ||\n      doc.type === 'clinic' ||\n      doc.type === 'health_center' ||\n      doc.type === 'district_hospital' ||\n      doc.type === 'national_office' ||\n      doc.type === 'person') {\n\n    var emitReference = function(prefix, key) {\n      emit([ prefix, String(key) ], doc.reported_date);\n    };\n\n    if (doc.place_id) {\n      emitReference('shortcode', doc.place_id);\n    }\n    if (doc.patient_id) {\n      emitReference('shortcode', doc.patient_id);\n    }\n    if (doc.rc_code) {\n      // need String because rewriter wraps everything in quotes\n      // keep refid case-insenstive since data is usually coming from SMS\n      emitReference('external', String(doc.rc_code).toUpperCase());\n    }\n  }\n}"
        },
        "contacts_by_type": {
          "map": "function(doc) {\n  var types = [ 'district_hospital', 'health_center', 'clinic', 'person' ];\n  var idx;\n  var type;\n  if (doc.type === 'contact') {\n    type = doc.contact_type;\n    idx = types.indexOf(type);\n    if (idx === -1) {\n      idx = type;\n    }\n  } else {\n    type = doc.type;\n    idx = types.indexOf(type);\n  }\n  if (idx !== -1) {\n    var dead = !!doc.date_of_death;\n    var muted = !!doc.muted;\n    var order = dead + ' ' + muted + ' ' + idx + ' ' + (doc.name && doc.name.toLowerCase());\n    emit([ type ], order);\n  }\n}"
        },
        "data_records_by_type": {
          "reduce": "_count",
          "map": "function(doc) {\n  if (doc.type === 'data_record') {\n    emit(doc.form ? 'report' : 'message');\n  }\n}"
        },
        "contacts_by_type_freetext": {
          "map": "function(doc) {\n  var skip = [ '_id', '_rev', 'type', 'refid', 'geolocation' ];\n\n  var usedKeys = [];\n  var emitMaybe = function(type, key, value) {\n    if (usedKeys.indexOf(key) === -1 && // Not already used\n        key.length > 2 // Not too short\n    ) {\n      usedKeys.push(key);\n      emit([ type, key ], value);\n    }\n  };\n\n  var emitField = function(type, key, value, order) {\n    if (!key || !value) {\n      return;\n    }\n    key = key.toLowerCase();\n    if (skip.indexOf(key) !== -1 || /_date$/.test(key)) {\n      return;\n    }\n    if (typeof value === 'string') {\n      value = value.toLowerCase();\n      value.split(/\\s+/).forEach(function(word) {\n        emitMaybe(type, word, order);\n      });\n    }\n    if (typeof value === 'number' || typeof value === 'string') {\n      emitMaybe(type, key + ':' + value, order);\n    }\n  };\n\n  var types = [ 'district_hospital', 'health_center', 'clinic', 'person' ];\n  var idx;\n  var type;\n  if (doc.type === 'contact') {\n    type = doc.contact_type;\n    idx = types.indexOf(type);\n    if (idx === -1) {\n      idx = type;\n    }\n  } else {\n    type = doc.type;\n    idx = types.indexOf(type);\n  }\n  if (idx !== -1) {\n    var dead = !!doc.date_of_death;\n    var muted = !!doc.muted;\n    var order = dead + ' ' + muted + ' ' + idx + ' ' + (doc.name && doc.name.toLowerCase());\n    Object.keys(doc).forEach(function(key) {\n      emitField(type, key, doc[key], order);\n    });\n  }\n}"
        },
        "doc_by_type": {
          "map": "function(doc) {\n  if (doc.type === 'translations') {\n    emit([ 'translations', doc.enabled ], {\n      code: doc.code,\n      name: doc.name\n    });\n    return;\n  }\n  emit([ doc.type ]);\n}"
        },
        "docs_by_id_lineage": {
          "map": "function(doc) {\n\n  var emitLineage = function(contact, depth) {\n    while (contact && contact._id) {\n      emit([ doc._id, depth++ ], { _id: contact._id });\n      contact = contact.parent;\n    }\n  };\n\n  var types = [ 'contact', 'district_hospital', 'health_center', 'clinic', 'person' ];\n\n  if (types.indexOf(doc.type) !== -1) {\n    // contact\n    emitLineage(doc, 0);\n  } else if (doc.type === 'data_record' && doc.form) {\n    // report\n    emit([ doc._id, 0 ]);\n    emitLineage(doc.contact, 1);\n  }\n}"
        },
        "messages_by_contact_date": {
          "reduce": "function(key, values) {\n  var latest = { date: 0 };\n  values.forEach(function(value) {\n    if (value.date > latest.date) {\n      latest = value;\n    }\n  });\n  return latest;\n}",
          "map": "function(doc) {\n\n  var emitMessage = function(doc, contact, phone) {\n    var id = (contact && contact._id) || phone || doc._id;\n    emit([ id, doc.reported_date ], {\n      id: doc._id,\n      date: doc.reported_date,\n      contact: contact && contact._id\n    });\n  };\n\n  if (doc.type === 'data_record' && !doc.form) {\n    if (doc.kujua_message && doc.tasks) {\n      // outgoing\n      doc.tasks.forEach(function(task) {\n        var message = task.messages && task.messages[0];\n        if(message) {\n          emitMessage(doc, message.contact, message.to);\n        }\n      });\n    } else if (doc.sms_message) {\n      // incoming\n      emitMessage(doc, doc.contact, doc.from);\n    }\n  }\n}"
        },
        "registered_patients": {
          "map": "// NB: This returns *registrations* for contacts. If contacts are created by\n//     means other then sending in a registration report (eg created in the UI)\n//     they will not show up in this view.\n//\n//     For a view with all patients by their shortcode, use:\n//        medic/docs_by_shortcode\nfunction(doc) {\n  var patientId = doc.patient_id || (doc.fields && doc.fields.patient_id);\n  var placeId = doc.place_id || (doc.fields && doc.fields.place_id);\n\n  if (!doc.form || doc.type !== 'data_record' || (doc.errors && doc.errors.length)) {\n    return;\n  }\n\n  if (patientId) {\n    emit(String(patientId));\n  }\n\n  if (placeId) {\n    emit(String(placeId));\n  }\n}"
        },
        "reports_by_date": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' && doc.form) {\n    emit([doc.reported_date], doc.reported_date);\n  }\n}"
        },
        "reports_by_form": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' && doc.form) {\n    emit([doc.form], doc.reported_date);\n  }\n}",
          "reduce": "function() {\n  return true;\n}"
        },
        "reports_by_freetext": {
          "map": "function(doc) {\n  var skip = [ '_id', '_rev', 'type', 'refid', 'content' ];\n\n  var usedKeys = [];\n  var emitMaybe = function(key, value) {\n    if (usedKeys.indexOf(key) === -1 && // Not already used\n        key.length > 2 // Not too short\n    ) {\n      usedKeys.push(key);\n      emit([key], value);\n    }\n  };\n\n  var emitField = function(key, value, reportedDate) {\n    if (!key || !value) {\n      return;\n    }\n    key = key.toLowerCase();\n    if (skip.indexOf(key) !== -1 || /_date$/.test(key)) {\n      return;\n    }\n    if (typeof value === 'string') {\n      value = value.toLowerCase();\n      value.split(/\\s+/).forEach(function(word) {\n        emitMaybe(word, reportedDate);\n      });\n    }\n    if (typeof value === 'number' || typeof value === 'string') {\n      emitMaybe(key + ':' + value, reportedDate);\n    }\n  };\n\n  if (doc.type === 'data_record' && doc.form) {\n    Object.keys(doc).forEach(function(key) {\n      emitField(key, doc[key], doc.reported_date);\n    });\n    if (doc.fields) {\n      Object.keys(doc.fields).forEach(function(key) {\n        emitField(key, doc.fields[key], doc.reported_date);\n      });\n    }\n    if (doc.contact && doc.contact._id) {\n      emitMaybe('contact:' + doc.contact._id.toLowerCase(), doc.reported_date);\n    }\n  }\n}"
        },
        "reports_by_place": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' && doc.form) {\n    var place = doc.contact && doc.contact.parent;\n    while (place) {\n      if (place._id) {\n        emit([ place._id ], doc.reported_date);\n      }\n      place = place.parent;\n    }\n  }\n}"
        },
        "reports_by_subject": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' && doc.form) {\n    var emitField = function(obj, field) {\n      if (obj[field]) {\n        emit(obj[field], doc.reported_date);\n      }\n    };\n\n    emitField(doc, 'patient_id');\n    emitField(doc, 'place_id');\n    emitField(doc, 'case_id');\n\n    if (doc.fields) {\n      emitField(doc.fields, 'patient_id');\n      emitField(doc.fields, 'place_id');\n      emitField(doc.fields, 'case_id');\n      emitField(doc.fields, 'patient_uuid');\n      emitField(doc.fields, 'place_uuid');\n    }\n  }\n}"
        },
        "reports_by_validity": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' && doc.form) {\n    emit([!doc.errors || doc.errors.length === 0], doc.reported_date);\n  }\n}"
        },
        "tasks_by_contact": {
          "map": "function(doc) {\n  if (doc.type === 'task') {\n    var isTerminalState = ['Cancelled', 'Completed', 'Failed'].indexOf(doc.state) >= 0;\n    var owner = (doc.owner || '_unassigned');\n\n    if (!isTerminalState) {\n      emit('owner-' + owner);\n    }\n\n    if (doc.requester) {\n      emit('requester-' + doc.requester);\n    }\n\n    emit(['owner', 'all', owner], { state: doc.state });\n  }\n}"
        },
        "reports_by_verification": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' && doc.form) {\n    emit([doc.verified], doc.reported_date);\n  }\n}"
        },
        "visits_by_date": {
          "map": "function(doc) {\n  if (doc.type === 'data_record' &&\n      doc.form &&\n      doc.fields &&\n      doc.fields.visited_contact_uuid) {\n\n    var visited_date = doc.fields.visited_date ? Date.parse(doc.fields.visited_date) : doc.reported_date;\n\n    // Is a visit report about a family\n    emit(visited_date, doc.fields.visited_contact_uuid);\n    emit([doc.fields.visited_contact_uuid, visited_date]);\n  }\n}"
        },
        "total_clinics_by_facility": {
          "map": "function(doc) {\n  var districtId = doc.parent && doc.parent.parent && doc.parent.parent._id;\n  if (doc.type === 'clinic' || (doc.type === 'contact' && districtId)) {\n    var healthCenterId = doc.parent && doc.parent._id;\n    emit([ districtId, healthCenterId, doc._id, 0 ]);\n    if (doc.contact && doc.contact._id) {\n      emit([ districtId, healthCenterId, doc._id, 1 ], { _id: doc.contact._id });\n    }\n    var index = 2;\n    var parent = doc.parent;\n    while(parent) {\n      if (parent._id) {\n        emit([ districtId, healthCenterId, doc._id, index++ ], { _id: parent._id });\n      }\n      parent = parent.parent;\n    }\n  }\n}"
        }
      },
      "version": "4.10.0-dev.1723635703462"
    },
    {
      "_id": "_design/medic-conflicts",
      "build_info": {
        "application": "medic",
        "author": "npm on kossi",
        "base_version": "4.10.0",
        "build": "4.10.0-dev.1723635703462",
        "schema_version": 2,
        "time": "2024-08-14T11:41:43.565Z",
        "namespace": "medic",
        "version": "4.10.0-local-development"
      },
      "version": "4.10.0-dev.1723635703462",
      "views": {
        "conflicts": {
          "reduce": "_count",
          "map": "function(doc) {\n  if (doc._conflicts) {\n    emit(doc._conflicts);\n  }\n}"
        }
      }
    },
    {
      "_id": "_design/medic-scripts",
      "build_info": {
        "application": "medic",
        "author": "npm on kossi",
        "base_version": "4.10.0",
        "build": "4.10.0-dev.1723635703462",
        "namespace": "medic",
        "schema_version": 2,
        "time": "2024-08-14T11:41:43.565Z",
        "version": "4.10.0-local-development"
      },
      "version": "4.10.0-dev.1723635703462",
      "views": {
        "data_records_by_ancestor": {
          "map": "// Only used in ./scripts/delete_training_data_utils.js\nfunction(doc) {\n  if (doc.type === 'data_record') {\n    var contact = doc.contact;\n    while (contact) {\n      if (contact._id) {\n        emit(contact._id);\n      }\n      contact = contact.parent;\n    }\n  }\n}"
        },
        "places_by_contact": {
          "map": "function(doc) {\n  if (\n    doc.contact &&\n    doc.contact._id &&\n    (\n      doc.type === 'contact' ||\n      doc.type === 'clinic' ||\n      doc.type === 'health_center' ||\n      doc.type === 'district_hospital'\n    )\n  ) {\n    emit(doc.contact._id);\n  }\n}"
        },
        "data_records": {
          "map": "// Mostly used for exporting records\nfunction(doc) {\n  if (doc.type === 'data_record') {\n    var valid = !doc.errors || doc.errors.length === 0;\n    var form = doc.form;\n\n    emit([doc.reported_date]);\n\n    if (form) {\n      emit([valid, form, doc.reported_date]);\n      emit([valid, '*', doc.reported_date]);\n    }\n\n    var parent = doc.contact;\n    while(parent) {\n      if (parent._id) {\n        emit([parent._id, doc.reported_date]);\n        if (form) {\n          emit([valid, parent._id, form, doc.reported_date]);\n          emit([valid, parent._id, '*', doc.reported_date]);\n        }\n      }\n      parent = parent.parent;\n    }\n  }\n}"
        },
        "places_by_type_parent_id_name": {
          "map": "// Only used by /scripts/delete_clinics_for_place.js\nfunction (doc) {\n  if (doc.type === 'contact' ||\n      doc.type === 'clinic' ||\n      doc.type === 'health_center' ||\n      doc.type === 'district_hospital' ||\n      doc.type === 'national_office') {\n    var pid = doc.parent ? doc.parent._id : null;\n    emit([doc.type, pid, doc.name], {name: doc.name});\n  }\n}"
        }
      }
    },
    {
      "_id": "_design/medic-sms",
      "build_info": {
        "application": "medic",
        "build": "4.10.0-dev.1723635703462",
        "schema_version": 2,
        "namespace": "medic",
        "time": "2024-08-14T11:41:43.565Z",
        "version": "4.10.0-local-development",
        "base_version": "4.10.0",
        "author": "npm on kossi"
      },
      "version": "4.10.0-dev.1723635703462",
      "views": {
        "gateway_messages_by_state": {
          "map": "function (doc) {\n  var _emit = function(tasks) {\n    tasks.forEach(function(task) {\n      if (!task.messages || !task.gateway_ref) {\n        return;\n      }\n\n      task.messages.forEach(function(msg) {\n        if (msg.uuid && msg.to && msg.message) {\n          var value = {\n            id: msg.uuid,\n            gateway_ref: task.gateway_ref,\n          };\n          emit(task.state, value);\n\n        }\n      });\n    });\n  };\n  _emit(doc.tasks || []);\n  _emit(doc.scheduled_tasks || []);\n}"
        },
        "messages_by_gateway_ref": {
          "map": "function(doc) {\n  var _emitMsg = function(ref, uuid) {\n    if (ref) {\n      emit(ref, uuid);\n    }\n  };\n\n  // outgoing\n  var _emit = function(tasks) {\n    tasks.forEach(function(task) {\n      if (task.messages) {\n        task.messages.forEach(function(msg) {\n          _emitMsg(task.gateway_ref, msg.uuid)\n        });\n      }\n    });\n  };\n  _emit(doc.tasks || []);\n  _emit(doc.scheduled_tasks || []);\n\n  // incoming\n  if (doc.type === 'data_record' && doc.sms_message) {\n    _emitMsg(doc.sms_message.gateway_ref, doc.sms_message.uuid);\n  }\n}"
        },
        "messages_by_uuid": {
          "map": "function (doc) {\n  var _emit = function(tasks) {\n    tasks.forEach(function(task) {\n      if (task.messages) {\n        task.messages.forEach(function(msg) {\n          if (msg.uuid) {\n            emit(msg.uuid);\n          }\n        });\n      }\n    });\n  };\n  _emit(doc.tasks || []);\n  _emit(doc.scheduled_tasks || []);\n}"
        },
        "messages_by_last_updated_state": {
          "map": "function (doc) {\n  var finalStatuses = ['sent', 'delivered', 'failed'];\n  var mutedStatuses = ['muted', 'cleared', 'denied', 'duplicate'];\n  var scheduledStatus = 'scheduled';\n\n  var _emit = function(tasks) {\n    tasks.forEach(function(task) {\n      var history = task.state_history && task.state_history[task.state_history.length - 1];\n      var lastUpdated = new Date(history && history.timestamp || task.timestamp || doc.reported_date).getTime();\n\n      var statusGroup = 'pending';\n      if (task.state === scheduledStatus) {\n        statusGroup = scheduledStatus;\n      } else if (finalStatuses.indexOf(task.state) > -1) {\n        statusGroup = 'final';\n      } else if (mutedStatuses.indexOf(task.state) > -1) {\n        statusGroup = 'muted';\n      }\n\n      emit([statusGroup, lastUpdated, task.state]);\n    });\n  };\n  _emit(doc.tasks || []);\n  _emit(doc.scheduled_tasks || []);\n}"
        }
      }
    }
  ]
}